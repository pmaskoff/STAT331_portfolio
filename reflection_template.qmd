---
title: "STAT 331 Portfolio"
author: "Parker Mascott"
format: 
  html: 
    self-contained: true
layout: margin-left
editor: visual
execute: 
  eval: false
  echo: true
---

[**My Grade:**]{.underline} I believe my grade equivalent to course work evidenced below to be an A-.

[**Learning Objective Evidence:**]{.underline} In the code chunks below, provide code from Lab or Challenge assignments where you believe you have demonstrated proficiency with the specified learning target. Be sure to specify **where** the code came from (e.g., Lab 4 Question 2).

## Working with Data

**WD-1: I can import data from a *variety* of formats (e.g., csv, xlsx, txt, etc.).**

-   `csv`

```{r}
#| label: wd-1-csv
#| eval: false
#| warning: false

# From Lab 2 Question 1
surveys <- read_csv(here("data","surveys.csv"))
```

-   `xlsx`

```{r}
#| label: wd-1-xlsx
# PA4, Question 3 Knowing how missing values look in the df
military <- read_xlsx(here::here("data", 
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Share of Govt. spending", 
                      skip  = 7, 
                      n_max = 190,
                      na = c(". .","xxx")
                      )
```

-   `txt`

```{r}
#| label: wd-1-txt
# Check-in 2.3 Question 3
ages_tab <- read_table(file = here::here("Week 2", "Check-ins", "Ages_Data", "ages_tab.txt"))
```

**WD-2: I can select necessary columns from a dataset.**

```{r}
#| label: wd-2
# Lab 3 Question 5
teachers_clean <- teachers |>
  mutate(sex = gender,
         course_id = as.character(course_id),
         teacher_id = as.character(teacher_id)) |>
  filter(no_participants >= 10) |>
  select(course_id, 
         teacher_id, 
         question_no, 
         no_participants, 
         resp_share, 
         SET_score_avg, 
         percent_failed_cur, 
         academic_degree, 
         seniority, 
         sex)
# Revised to have better formatting, returning to a new line after 
# each separate input for select() and also changing the name of 
# the dataset to better describe it. Before, I had it as 
# teachers_1, which creates a new dataset but doesn't give 
# any context on what it is besides a copy. teachers_clean gives
# information that this dataset is better than the last, is refined, 
# and should be used.
```

**WD-3: I can filter rows from a dataframe for a *variety* of data types (e.g., numeric, integer, character, factor, date).**

-   numeric

```{r}
#| label: wd-3-numeric
# Lab 3 Question 5
teachers_clean <- teachers |>
  mutate(sex = gender,
         course_id = as.character(course_id),
         teacher_id = as.character(teacher_id)) |>
  filter(no_participants >= 10) |>
  select(course_id, 
         teacher_id, 
         question_no, 
         no_participants, 
         resp_share, 
         SET_score_avg, 
         percent_failed_cur, 
         academic_degree, 
         seniority, 
         sex)
# Revised to have better formatting, returning to a new line after 
# each separate input for select() and also changing the name of 
# the dataset to better describe it. Before, I had it as 
# teachers_1, which creates a new dataset but doesn't give 
# any context on what it is besides a copy. teachers_clean gives
# information that this dataset is better than the last, is refined, 
# and should be used.
```

-   character -- specifically a string (example must use functions from **stringr**)

```{r}
#| label: wd-3-string
# Lab 5
drivers_license_filter <- drivers_license |>
  filter(str_detect(plate_number, "H42W"))
```

-   factor

```{r}
#| label: wd-3-factor
# Lab 7 Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

-   date (example must use functions from **lubridate**)

```{r}
#| label: wd-3-date
# Lab 5
gym_check_ins <- get_fit_now_check_in |>
  mutate(check_in_date = ymd(check_in_date)) |>
  filter(str_detect(membership_id, "^48Z"), 
         check_in_date == as.Date("2018-01-09"))
```

**WD-4: I can modify existing variables and create new variables in a dataframe for a *variety* of data types (e.g., numeric, integer, character, factor, date).**

-   numeric (using `as.numeric()` is not sufficient)

```{r}
#| label: wd-4-numeric
# Lab 3 Question 5
teachers_1 |>
  filter(question_no == 901) |>
  group_by(teacher_id) |>
  summarise(avg_q1 = mean(SET_score_avg, na.rm = TRUE)) |>
  mutate(
    rank = case_when(
      avg_q1 == max(avg_q1) ~ "Highest",
      avg_q1 == min(avg_q1) ~ "Lowest",
      TRUE ~ "" 
    )
  ) |>
  filter(rank != "") |>
  print()
```

-   character -- specifically a string (example must use functions from **stringr**)

```{r}
#| label: wd-4-string
# Lab 2 Question 8
surveys <- surveys |>
  mutate(species_group = str_sub(species, 1, 1))

ggplot(data = surveys,
       mapping = aes(x = species_group, y = weight)) +
  geom_boxplot() +
  labs(title = "Weight Distribution by Species Group",
       x = "Species Group",
       y = "Weight (g)")

# Revised to make a cleaner graph
```

-   factor (example must use functions from **forcats**)

```{r}
#| label: wd-4-factor
# Lab 7 Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop") |>
  mutate(species = fct_reorder2(species, year, avg_cindex, .desc = TRUE))

# Revised so wouldn't have to use fct_reorder2 in the ggplot pipeline
```

-   date (example must use functions from **lubridate**)

```{r}
#| label: wd-4-date
# Lab 5
gym_check_ins <- get_fit_now_check_in |>
  mutate(check_in_date = ymd(check_in_date)) |>
  filter(str_detect(membership_id, "^48Z"),
         check_in_date == as.Date("2018-01-09"))
```

**WD-5: I can use mutating joins to combine multiple dataframes.**

-   `left_join()`

```{r}
#| label: wd-5-left
# Lab 5
gym_check_ins <- get_fit_now_check_in |>
  mutate(check_in_date = ymd(check_in_date)) |>
  filter(str_detect(membership_id, "^48Z"),
         check_in_date == as.Date("2018-01-09"))

# Relevant check-ins Left Join
gym_with_members <- gym_check_ins |>
  left_join(get_fit_now_member, by = c("membership_id" = "id"))

# Match
gym_suspects <- gym_with_members |>
  inner_join(person, by = c("person_id" = "id"))
```

-   `right_join()`

```{r}
#| label: wd-5-right
# Lab 5
gym_check_ins <- get_fit_now_check_in |>
  mutate(check_in_date = ymd(check_in_date)) |>
  filter(str_detect(membership_id, "^48Z"),
         check_in_date == as.Date("2018-01-09"))

# Relevant check-ins Right Join
gym_with_members <- get_fit_now_member |>
  right_join(gym_check_ins, by = c("id" = "membership_id"))

# Match
gym_suspects <- gym_with_members |>
  inner_join(person, by = c("person_id" = "id"))
```

-   `inner_join()`

```{r}
#| label: wd-5-inner
# Lab 4 Question 2
ca_counties <- counties |>
  filter(state_abbreviation == "CA")

ca_childcare <- childcare_costs |>
  inner_join(ca_counties,
             by = "county_fips_code")
```

-   `full_join()`

```{r}
#| label: wd-5-full
# NOT APPLICABLE
```

**WD-6: I can use filtering joins to filter rows from a dataframe.**

-   `semi_join()`

```{r}
#| label: wd-6-semi
# Lab 5 FINAL JOIN
gym_suspects <- get_fit_now_member |>
  semi_join(gym_check_ins, by = c("id" = "membership_id")) |>
  semi_join(person, by = c("person_id" = "id"))

# Used a semi-join to match membership IDs and connect it to the person df.
```

-   `anti_join()`

```{r}
#| label: wd-6-anti
# Lab 4 Question 4
missing_years <- median_income_region |>
  pivot_longer(cols = `2008`:`2018`,
               names_to = "year",
               values_to = "income") |>
  filter(is.na(income)) |>
  anti_join(data_2018, by = "census_region")
# Added to check if there was any years that were missing values, which could affect the graph
```

**WD-7: I can pivot dataframes from long to wide and visa versa**

-   `pivot_longer()`

```{r}
#| label: wd-7-long
# Lab 7 Question 1
fish_missing_summary <- fish |>
  summarise(across(everything(), ~ sum(is.na(.)), .names = "missing_{.col}")) |>
  pivot_longer(cols = starts_with("missing"), 
               names_to = "variable", 
               values_to = "missing_count")

fish_missing_summary |>
  kable()

```

-   `pivot_wider()`

```{r}
#| label: wd-7-wide
# Lab 9 Question 2
enframed <- enframe(results, 
                      name = "simulation_number", 
                      value = "ncorrect")

proportions <- enframed |>
  count(ncorrect) |>
  mutate(proportion = n / sum(n)) |>
  select(ncorrect, proportion) |>
  pivot_wider(names_from = ncorrect, 
              values_from = proportion, 
              names_prefix = "ncorrect_")
```

## Reproducibility

**R-1: I can create professional looking, reproducible analyses using RStudio projects, Quarto documents, and the here package.**

I've done this in the following provided assignments: Lab 2 + Challenge, Lab 3 + Challenge, Lab 4, Lab 5

**R-2: I can write well documented and tidy code.**

-   Example of **ggplot2** plotting

```{r}
#| label: r-2-1
ggplot(data = teacher_evals_compare,
        aes(x = sen_level, 
            fill = SET_level)) +
  geom_bar(position = "fill") +
  labs(x = "Seniority of Instructor",
       y = "",
       subtitle = "Number of Sections") +
  scale_fill_manual(values = c("excellent" = "#43719e",
                               "standard" = "#da7f2d")) +
  theme_minimal()
```

-   Example of **dplyr** pipeline

```{r}
#| label: r-2-2
# Lab 3 Question 5
teachers_clean <- teachers |>
  mutate(sex = gender,
         course_id = as.character(course_id),
         teacher_id = as.character(teacher_id)) |>
  filter(no_participants >= 10) |>
  select(course_id, 
         teacher_id, 
         question_no, 
         no_participants, 
         resp_share, 
         SET_score_avg, 
         percent_failed_cur, 
         academic_degree, 
         seniority, 
         sex)

# Revised to have better formatting, returning to a new line after 
# each separate input for select() and also changing the name of 
# the dataset to better describe it. Before, I had it as 
# teachers_1, which creates a new dataset but doesn't give 
# any context on what it is besides a copy. teachers_clean gives
# information that this dataset is better than the last, is refined, 
# and should be used.
```

-   Example of function formatting

```{r}
#| label: r-2-3
# Lab 9 Question 1
randomBabies <- function(nBabies){
  samplebabes <- sample(1:nBabies, size = nBabies, replace = FALSE)
  correct <- sum(samplebabes == 1:nBabies)
  return(correct)
}

results <- map_int(.x = 1:10000,
                   .f = ~ randomBabies(n = 4)
                   )
```

**R-3: I can write robust programs that are resistant to changes in inputs.**

-   Example -- any context

```{r}
#| label: r-3-example
# Lab 5
lasthouse <- person |>
  filter(address_street_name == "Northwestern Dr") |>
  slice_max(address_number, n = 1)

if (nrow(lasthouse) == 0) stop("No houses found on Northwestern Dr!")

# Witness: Annabel on Franklin Ave
annabel <- person |>
  filter(str_detect(name, "Annabel"),
         address_street_name == "Franklin Ave")

# Combine witnesses
witnesses <- lasthouse |>
  bind_rows(annabel)

witnesses
```

-   Example of function stops

```{r}
#| label: r-3-function-stops
# Lab 7 Challenge Question 4
cindex <- function(weight, length) {
  stopifnot(is.numeric(weight), is.numeric(length))
  stopifnot(length(weight) == length(length))
  cindex_value <- (weight / length^3) * 100
  return(cindex_value)
}
```

## Data Visualization & Summarization

**DVS-1: I can create visualizations for a *variety* of variable types (e.g., numeric, character, factor, date)**

-   at least two numeric variables

```{r}
#| label: dvs-1-num
# Lab 2 Challenge, Question 16
ggplot(data = surveys,
       mapping = aes(x = weight,
                     y = hindfoot_length, labs)) +
  labs(title = "Weight vs. Length of the Hindfoot across Species",
       x = "Weight of the animal in grams",
       y = "",
       subtitle = "Length of the Hindfoot in mm") +
  geom_boxplot(outliers = FALSE) +
  geom_jitter(color = "orange3",
              alpha = 0.1) +
  facet_wrap(~species) +
  theme(axis.text.y = element_text(angle = 45),
        axis.text.x = element_text(angle = 45)) +
  coord_flip()

# Revised. I had `labs` as a variable so moved the `labs` function outside of the `aes()`.
```

-   at least one numeric variable and one categorical variable

```{r}
#| label: dvs-2-num-cat
ggplot(data = surveys,
       mapping = aes(x = weight,
                     y = hindfoot_length, labs)) +
  labs(title = "Weight vs. Length of the Hindfoot across Species",
       x = "Weight of the animal in grams",
       y = "",
       subtitle = "Length of the Hindfoot in mm") +
  geom_boxplot(outliers = FALSE) +
  geom_jitter(color = "orange3",
              alpha = 0.1) +
  facet_wrap(~species) +
  theme(axis.text.y = element_text(angle = 45),
        axis.text.x = element_text(angle = 45)) +
  coord_flip()
```

-   at least two categorical variables

```{r}
#| label: dvs-2-cat
# Lab 3 Challenge, Queston 2
ggplot(data = teacher_evals_compare,
        aes(x = sen_level, 
            fill = SET_level)) +
  geom_bar(position = "fill") +
  labs(x = "Seniority of Instructor",
       y = "",
       subtitle = "Number of Sections") +
  scale_fill_manual(values = c("excellent" = "#43719e",
                               "standard" = "#da7f2d")) +
  theme_minimal()
```

-   dates (timeseries plot)

```{r}
#| label: dvs-2-date
# Lab 4 Question 6

ggplot(plot_data, aes(x = study_year, y = median_price, color = census_region)) +
  geom_point() +
  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~ age_group, ncol = 3) +
  labs(
    title = "Weekly Median Price for Center-Based Childcare ($)",
    x = "Study Year",
    y = "Weekly Median Price",
    color = "California Region"
  ) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
```

**DVS-2: I use plot modifications to make my visualization clear to the reader.**

-   I can ensure people don't tilt their head

```{r}
#| label: dvs-2-1
# Lab 7 Challenge, Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

-   I can modify the text in my plot to be more readable

```{r}
#| label: dvs-2-2
# Lab 7 Challenge, Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

-   I can reorder my legend to align with the colors in my plot

```{r}
#| label: dvs-2-3
# Lab 7 Challenge, Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

**DVS-3: I show creativity in my visualizations**

-   I can use non-standard colors

```{r}
#| label: dvs-3-1
# Lab 7 Challenge, Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

-   I can use annotations

```{r}
#| label: dvs-3-2
# Lab 7 Challenge, Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

-   I can be creative...

```{r}
#| label: dvs-3-3
# Lab 7 Challenge, Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

**DVS-4: I can calculate numerical summaries of variables.**

-   Example using `summarize()`

```{r}
#| label: dvs-4-summarize
# Lab 7 Question 1
fish_missing_summary <- fish |>
  summarise(across(everything(), ~ sum(is.na(.)), .names = "missing_{.col}")) |>
  pivot_longer(cols = starts_with("missing"), 
               names_to = "variable", 
               values_to = "missing_count")

fish_missing_summary |>
  kable()
```

-   Example using `across()`

```{r}
#| label: dvs-4-across
# Lab 7 Question 1
fish_missing_summary <- fish |>
  summarise(across(everything(), ~ sum(is.na(.)), .names = "missing_{.col}")) |>
  pivot_longer(cols = starts_with("missing"), 
               names_to = "variable", 
               values_to = "missing_count")

fish_missing_summary |>
  kable()
```

**DVS-5: I can find summaries of variables across multiple groups.**

-   Example 1

```{r}
#| label: dvs-5-1
# Lab 4, Question 4
data_2018 <- ca_childcare |>
  group_by(census_region,
           study_year) |>
  summarise(median_household_income = median(mhi_2018), .groups = "drop")
```

-   Example 2

```{r}
#| label: dvs-5-2
# Lab 7 Challenge, Question 5
fish_summary <- fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop")

ggplot(data = fish_summary,
       aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

**DVS-6: I can create tables which make my summaries clear to the reader.**

-   Example 1

```{r}
#| label: dvs-6-1
# Lab 9 Problem 2
enframed <- enframe(results, 
                      name = "simulation_number", 
                      value = "ncorrect")

proportions <- enframed |>
  count(ncorrect) |>
  mutate(proportion = n / sum(n)) |>
  select(ncorrect, proportion) |>
  pivot_wider(names_from = ncorrect, 
              values_from = proportion, 
              names_prefix = "ncorrect_")


proportions |>
  gt() |>
    tab_header(
    title = "Proportion of Simulations by Number of Correctly Returned Babies",
    subtitle = "Based on 10,000 simulations"
  ) |>
  cols_label(
    ncorrect_0 = "0 Correct",
    ncorrect_1 = "1 Correct",
    ncorrect_2 = "2 Correct",
    ncorrect_4 = "4 Correct"
  ) |>
  cols_align(
    align = "center",
    columns = everything()
  )

# Revised to use gt() function and make table creative and readable. Using titles and renaming columns
```

-   Example 2

```{r}
#| label: dvs-6-2
# Lab 9 Question 7
r5 <- function(n) {
  rounded <- round(n, 5)
  return(rounded)
}

summaries <- all_simulations |> 
  group_by(n) |> 
  summarize(mean_sim_mean = r5(mean(simulated_means)),
            sd_sim_mean = r5(sd(simulated_means)),
            min_sim_mean = r5(min(simulated_means)),
            max_sim_mean = r5(max(simulated_means)),
            .groups = 'drop')

summaries |>
  gt() |>
    tab_header(
    title = "Means of Statistics Across Simulations",
    subtitle = "Including means of means, standard deviations, minimums, and maximums"
  ) |>
  cols_label(
    n = "Simulations",
    mean_sim_mean = "Mean",
    sd_sim_mean = "SD",
    min_sim_mean = "Minimum",
    max_sim_mean = "Maximum",
  ) |>
  cols_align(
    align = "center",
    columns = everything()
  )

# Revised to use gt() function and make table creative and readable. Using titles and renaming columns
```

**DVS-7: I show creativity in my tables.**

-   Example 1

```{r}
#| label: dvs-7-1
# Lab 9 Question 7
r5 <- function(n) {
  rounded <- round(n, 5)
  return(rounded)
}

summaries <- all_simulations |> 
  group_by(n) |> 
  summarize(mean_sim_mean = r5(mean(simulated_means)),
            sd_sim_mean = r5(sd(simulated_means)),
            min_sim_mean = r5(min(simulated_means)),
            max_sim_mean = r5(max(simulated_means)),
            .groups = 'drop')

summaries |>
  gt() |>
    tab_header(
    title = "Means of Statistics Across Simulations",
    subtitle = "Including means of means, standard deviations, minimums, and maximums"
  ) |>
  cols_label(
    n = "Simulations",
    mean_sim_mean = "Mean",
    sd_sim_mean = "SD",
    min_sim_mean = "Minimum",
    max_sim_mean = "Maximum",
  ) |>
  cols_align(
    align = "center",
    columns = everything()
  )

# Revised to use gt() function and make table creative and readable. Using titles and renaming columns
```

-   Example 2

```{r}
#| label: dvs-7-2
# Lab 9 Question 7
r5 <- function(n) {
  rounded <- round(n, 5)
  return(rounded)
}

summaries <- all_simulations |> 
  group_by(n) |> 
  summarize(mean_sim_mean = r5(mean(simulated_means)),
            sd_sim_mean = r5(sd(simulated_means)),
            min_sim_mean = r5(min(simulated_means)),
            max_sim_mean = r5(max(simulated_means)),
            .groups = 'drop')

summaries |>
  gt() |>
    tab_header(
    title = "Means of Statistics Across Simulations",
    subtitle = "Including means of means, standard deviations, minimums, and maximums"
  ) |>
  cols_label(
    n = "Simulations",
    mean_sim_mean = "Mean",
    sd_sim_mean = "SD",
    min_sim_mean = "Minimum",
    max_sim_mean = "Maximum",
  ) |>
  cols_align(
    align = "center",
    columns = everything()
  )

# Revised to use gt() function and make table creative and readable. Using titles and renaming columns
```

## Program Efficiency

**PE-1: I can write concise code which does not repeat itself.**

-   using a single function call with multiple inputs (rather than multiple function calls)

```{r}
#| label: pe-1-one-call
# Lab 8 Challenge, Question 2
map_column_factor <- function(df, variables) {
  colfact <- map_at(df, variables, as.factor)
  bind_cols(colfact)
}

colfacts <- c("teacher_id", "weekday", "academic_degree", "seniority", "gender")

fct_evals <- map_column_factor(evals, colfacts)

fct_evals_type <- maptype(fct_evals)

fct_evals_type |>
  kable()
```

-   `across()`

```{r}
#| label: pe-1-across
# Lab 7 Question 1
fish_missing_summary <- fish |>
  summarise(across(everything(), ~ sum(is.na(.)), .names = "missing_{.col}")) |>
  pivot_longer(cols = starts_with("missing"), 
               names_to = "variable", 
               values_to = "missing_count")

fish_missing_summary |>
  kable()
```

-   `map()` functions

```{r}
#| label: pe-1-map-1
# Lab 8 Question 2
map_column_factor <- function(df, variables) {
  colfact <- map_at(df, variables, as.factor)
  bind_cols(colfact)
}

colfacts <- c("teacher_id", "weekday", "academic_degree", "seniority", "gender")

fct_evals <- map_column_factor(evals, colfacts)

fct_evals_type <- maptype(fct_evals)

fct_evals_type |>
  kable()

# Lab 8 Question 1
maptype <- function(df) {
  tibble(variable = names(df), 
         type = map_chr(df, class))
}

surveys_type <- maptype(surveys)

surveys_type <- surveys_type |>
  pivot_wider(names_from = variable,
              values_from = type)

surveys_type |>
  kable()
```

**PE-2: I can write functions to reduce repetition in my code.**

-   Function that operates on vectors

```{r}
#| label: pe-2-1
# Lab 7 Challenge Question 4
cindex <- function(weight, length) {
  stopifnot(is.numeric(weight), is.numeric(length))
  stopifnot(length(weight) == length(length))
  cindex_value <- (weight / length^3) * 100
  return(cindex_value)
}
```

-   Function that operates on data frames

```{r}
#| label: pe-2-2
# Lab 8 Question 1
maptype <- function(df) {
  tibble(variable = names(df), 
         type = map_chr(df, class))
}
```

**PE-3:I can use iteration to reduce repetition in my code.**

-   `across()`

```{r}
#| label: pe-3-across
# Lab 7 Question 1
fish_missing_summary <- fish |>
  summarise(across(everything(), ~ sum(is.na(.)), .names = "missing_{.col}")) |>
  pivot_longer(cols = starts_with("missing"), 
               names_to = "variable", 
               values_to = "missing_count")

fish_missing_summary |>
  kable()
```

-   `map()` function with **one** input (e.g., `map()`, `map_chr()`, `map_dbl()`, etc.)

```{r}
#| label: pe-3-map-1
# Lab 9 Question 4
simulate_means <- function(n, df){
  stopifnot(
    is.numeric(n),
    length(n) == 1,
    n > 0,
    is.numeric(df),
    length(df) == 1,
    df > 0
  )
  map_dbl(.x = 1:n, 
          .f = ~rchisq(n = 100, df) %>% mean()
          )
}
```

-   `map()` function with **more than one** input (e.g., `map_2()` or `pmap()`)

```{r}
#| label: pe-3-map-2
# Lab 9 Question 6
all_simulations <- grid |> 
  mutate(simulated_means = pmap(.l = list(n, df), 
                                .f = simulate_means)
         ) |> 
  unnest(cols = simulated_means) 
```

**PE-4: I can use modern tools when carrying out my analysis.**

-   I can use functions which are not superseded or deprecated

```{r}
#| label: pe-4-1
# Lab 9 Problem 2
enframed <- enframe(results, 
                      name = "simulation_number", 
                      value = "ncorrect")

proportions <- enframed |>
  count(ncorrect) |>
  mutate(proportion = n / sum(n)) |>
  select(ncorrect, proportion) |>
  pivot_wider(names_from = ncorrect, 
              values_from = proportion, 
              names_prefix = "ncorrect_")
```

-   I can connect a data wrangling pipeline into a `ggplot()`

```{r}
#| label: pe-4-2
fish |>
  mutate(cindex_value = cindex(weight, length)) |>
  group_by(year, species) |>
  summarise(avg_cindex = mean(cindex_value, na.rm = TRUE), .groups = "drop") |>
  ggplot(aes(x = year, 
           y = avg_cindex, 
           color = fct_reorder2(species, year, avg_cindex, .desc = TRUE), 
           group = species)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Fish Condition Indices Over Time by Species",
       x = "Year Of Study",
       y = "",
       subtitle = "Condition index: A measure of fish health based on weight and length",
       color = "Species"
  ) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  theme(text = element_text(family = "Futura", size = 12),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  annotate("text", x = 1998, y = 1.25, label = "Outlying Peak", color = "red")

# Revised, changed things like font, color, and titles so plot would be more appealing and readable. Also, added context for CI and what that meant, so the reader could understand. Organized legend so the top would be the species with the highest index value.
```

## Data Simulation & Statisical Models

**DSSM-1: I can simulate data from a *variety* of probability models.**

-   Example 1

```{r}
#| label: dsm-1-1
# Lab 9 Question 4
simulate_means <- function(n, df){
  stopifnot(
    is.numeric(n),
    length(n) == 1,
    n > 0,
    is.numeric(df),
    length(df) == 1,
    df > 0
  )
  map_dbl(.x = 1:n, 
          .f = ~rchisq(n = 100, df) %>% mean()
          )
}
```

-   Example 2

```{r}
#| label: dsm-1-2
# Lab 9 Question 1
randomBabies <- function(nBabies){
  samplebabes <- sample(1:nBabies, size = nBabies, replace = FALSE)
  correct <- sum(samplebabes == 1:nBabies)
  return(correct)
}

results <- map_int(.x = 1:10000,
                   .f = ~ randomBabies(n = 4)
                   )
```

**DSSM-2: I can conduct common statistical analyses in R.**

-   Example 1

```{r}
#| label: dsm-2-1
# Lab 1 Question 10
t.test(len ~ supp, data = ToothGrowth, var.equal = FALSE, alternative = "two.sided")
```

-   Example 2

```{r}
#| label: dsm-2-2
# Lab 2 Question 17
species_aov <- aov(weight~species, data = surveys)
summary(species_aov)
```

## Revising My Thinking

<!-- How did you revise your thinking throughout the course? How did you revise your thinking on the code examples you have provided in your portfolio? -->

Throughout this course, I have attempted to revise 99% of my assignments, I believe revising is where a lot of the learning happens. For some code examples in the portfolio, I revised because there was a little formatting issue, or it simply did not fit the question. If it did not fit the question, and I can see how I would be able to alter it, get the same result using a more efficient strategy, I went for it. For the actual assignments I tried my best to provide the best explanations/reflections possible for revisions. Really expanding on the why and thinking about the bigger picture was a strength of mine in my assignments.

<!-- For the revisions included in your Portfolio, to help me understand the nature of your revisions, please denote somehow the feedback I provided you (e.g., boldface, italics, colored text) before your revisions. -->

## Extending My Thinking

<!-- How did you extended your thinking throughout the course? How did you extend your thinking on the code examples you have provided in your portfolio? -->

I extended my thinking throughout this course by building on my previous work and constantly revising. I have also begun to build some projects on my own thanks to these new data skills I have learned. Cleaning, loading, and altering dataset skills have allowed me to start a personal project, getting data from online and cleaning it up to be exactly what I am looking for. For example, in the past I manually inputted soccer statistics for a small dataset, however with my new skills, after web scraping, I can clean the dataset. Filtering only the years and teams I want, pulling out individual statistics for my analyses. All the skills in this course are very useful which I am thankful for!

Specifically in this course, I have extended my thinking on revisions yes, but also on the recent Lab 5 assignment. This lab was completely self run, choosing which R operations to use to deduce the final suspect in a murder case is not something I imagined doing, however it was very fun! I would like to try something like that again in the future but at the end of the course to see how far I have come with my R skills.

## Peer Support & Collaboration

<!-- Include an image or a description of feedback you gave that you are proud of (either in a peer review or in Discord). -->

Peer review:\
Yanna this is amazing code. So nice to look at. If I had to say something about the formatting, I would say that personally it would be easier to follow your logic if you had to next to each line instead of in a text block before. If you do not think so, totally fine, it works as is.\

Your use of joins is very good, and your revisions do a great job finding the final suspect, I especially liked your use of the filter function in the final step, brilliant work.\

One final suggestion would be to embed your results, just having the dataset show for long text blocks like these doesn't give much for the reader, it gets cut off and they can't do some deductions themselves, which would have them more invested. You can do this by using

```{r}
`r datasetname[row#, "variable/column name"]`
# This would go inside your descriptions not in a code chunk, it is an embedding operation.
```

I know Dr. T has not mentioned this for their assignments but this is neat and quick way to access full data values.

Lastly, it is useful for stuff that is changing, lets say you had a simulation function that ran everytime you rendered it. You would need to embed a mean type of value because it would change everytime!\
Discord:

![](images/Screenshot%202024-11-05%20at%2010.59.38%20AM.png){width="404"}

<!-- Include a description of how you grew as a collaborator through the weekly pair programming activities.   -->

Through the weekly pair programming activities I have been able to collaborate extremely well with my partner. Although we have only had two different partners so far, I feel that I have connected with both of them, learned how they succeed and tried to support them as best I can during our activities. The coder and developer style learning has been very effective for me. Although sometimes, we itch to start coding while we are the developer, I enjoy putting my ideas into speech in these classes. Learning these coding skills using different strategies is very effective. Also, when putting ideas into speech, I help my teammates learn as well. If they are confused about a topic, hearing the developer talk their ideas out is useful.\
\
With every collaborative assignment, including other classwork as well. I try to be as helpful as possible. Sticking to the developer coder relationship, along with making sure my partner is comfortable and having their ideas be heard is my top priority. In the future, I will try to be more active on discord, posting and answering questions, so people can use my messages are a recourse.
